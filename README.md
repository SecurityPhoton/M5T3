# M5T3
Plugin used [kubectl ai](https://github.com/sozercan/kubectl-ai)

| NAME | PROMPT | DESCRIPTION | EXAMPLE |
|------|--------|-------------|---------|
| app.yaml | create a pod manifest with name app ith labels app: demo and run:demo for image gcr.io/k8s-k3s/demo:v1.0.0 that uses 8080 port. The port name is http | The Pod runs a single container named "app" using the "gcr.io/k8s-k3s/demo:v1.0.0" image. The container exposes port 8080 for HTTP traffic using the name "http". | [EXAMPLE](./yaml/app.yaml) |
| app-livenessProbe.yaml | create a pod manifest with  name: app-livenessprob in namespace demo. Add container image gcr.io/k8s-k3s/demo:v1.0.0 with name app. Add livenessProbe for port 8000 with delay 5 timeout 1 period 10 failure 3. Add ports: 8000 with name http. | The Pod is configured with a liveness probe that checks the container's health by making an HTTP request to the root path "/" on port 8000. The liveness probe has an initial delay of 5 seconds before it starts checking, and it checks the container's health every 10 seconds. If the probe fails three times in a row, the container is considered to have failed. | [EXAMPLE](./yaml/app-livenessProbe.yaml) |
| app-readinessProbe.yaml | create a pod manifest with  name: app-readinessprob. Add container image gcr.io/k8s-k3s/demo:v2.0.0 with name app. Add livenessProbe for port 8000 with delay 5 timeout 1 period 10 failure 3. Add ports: 8000 with name http. Add readynessProbe with path /ready for port 8000 period 2 delay 0 failure 3 success 1 | The Pod is configured with liveness and readiness probes that check the container's health and readiness by making HTTP requests. The liveness probe makes an HTTP request to the root path "/" on port 8000, and the readiness probe makes an HTTP request to the "/ready" path on port 8000. The liveness probe has an initial delay of 5 seconds before it starts checking, and it checks the container's health every 10 seconds. If the probe fails three times in a row, the container is considered to have failed. | [EXAMPLE](./yaml/app-readinessProbe.yaml) |
| app-volumeMounts.yaml | create a pod manifest with  name app-volume. Add container image gcr.io/kuar-demo/kuard-amd64:1 with name app. Add livenessProbe for port 8080 path /healthy with delay 5 timeout 1 period 10 failure 3. Add ports: 8080 with name http. Add readynessProbe with path /ready for port 8080 period 2 delay 0 failure 3 success 1. Add volume Mounts with path /data and name data. Add volumes name data and hostpath /var/lib/app | The Pod is also configured with a volume named "data" that is mounted at "/data" in the container. The volume is defined using a hostPath volume type, which means that it is backed by a directory on the host machine. In this case, the host directory is "/var/lib/app". This allows the container to read and write data to a directory on the host machine. | [EXAMPLE](./yaml/app-volumeMounts.yaml) |
| app-cronjob.yaml | create CronJob manifest with name  app-cronjob with shedule - every five min. Job template - name hello image bash with command echo Hello world. with restart policy onFailure |  CronJob manifest that creates a scheduled job to run a single container named "hello" using the "bash" image. The container runs a command that echoes "Hello world." The CronJob is configured to run every 5 minutes | [EXAMPLE](./yaml/app-cronjob.yaml) |
| app-job.yaml | create Job app-job-rsync. Volume name data-input gcePersistentDisk with pdname glow-data-disk-200 and fstype ext4. Container name init image google/cloud-sdk:275.0.0-alpine and command /bin/sh, -c, gsutil -m rsync -dr gs://glow-sportradar/ /data/input . Volumemounts with name data-input and mount /data/input . backoffLimit 0 | Job manifest that runs a single container named "init" using the "google/cloud-sdk:275.0.0-alpine" image. The container runs a command that uses gsutil to synchronize files from a Google Cloud Storage bucket to a persistent disk mounted at "/data/input". | [EXAMPLE](./yaml/app-job.yaml) |
| app-multicontainer.yaml | create a pod manifest with  name app-multi-containers. First Container name 1st image nginx volume mounts name html with path /usr/share/nginx/html. Second container with name 2nd image debian and volume mounts html /html. Command for 2nd container /bin/sh, -c with args while true; do date >> /html/index.html; sleep 1; done | manifest that runs two containers - "1st" and "2nd" - and mounts a shared volume between them | [EXAMPLE](./yaml/app-multicontainer.yaml) |
| app-resources.yaml | create a pod manifest with  name app-resource. Add container image gcr.io/kuar-demo/kuard-amd64:1 with name app. Add livenessProbe for port 8080 path /healthy with delay 5 timeout 1 period 10 failure 3. Add ports: 8080 with name http. Add readynessProbe with path /ready for port 8080 period 2 delay 0 failure 3 success 1. resources cpu 100 mem 128m limit cpu 100 mem 256m | manifest that runs a single container. The container has two probes - a liveness probe and a readiness probe - that check the container's health and readiness, respectively, by making HTTP requests to the "/healthy" and "/ready" endpoints on port 8080. The container is configured to use 100m CPU and 128Mi memory as resource requests, and 100m CPU and 256Mi memory as resource limits. The container also exposes port 8080 for HTTP traffic using the name "http". | [EXAMPLE](./yaml/app-multicontainer.yaml) | 
| app-secret-env.yaml | create pod name app-secret-env with container mycontainer image redis and restart policy never. Add env name SECRET_USERNAME from mysecret1 key username and env SECRET_PASSWORD from mysecret1 key password | This is a Kubernetes Pod manifest that sets environment variables for a container using a Kubernetes Secret. The Pod runs a single container using the Redis image and sets the "SECRET_USERNAME" and "SECRET_PASSWORD" environment variables using values from the "mysecret1" Secret. | [EXAMPLE](./yaml/app-secret-env.yaml) |
